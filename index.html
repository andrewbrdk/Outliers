<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Outliers</title>
	<link rel="stylesheet" href="uPlot/uPlot.min.css">
	<script src="uPlot/uPlot.iife.min.js"></script>
	<link rel="stylesheet" href="/style.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
	<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
</head>
<body>
	
<x-outliers></x-outliers>

<script>
class XOutliers extends HTMLElement {
	#login = null;
	#detectors = null;
	#detectorsData = null;
	#evSrc = null;
	
	constructor() {
		super();
		this.innerHTML = `
	 		<h1><a href="/">Outliers</a></h1>
			<x-login></x-login>
			<div id="detectors"></div>
		`;
		this.#detectors = this.querySelector('#detectors');
		this.#login = this.querySelector('x-login');
		this.#login.hidden = true;
		this.#detectors.hidden = true;
		this.addEventListener('loginsuccess', (e) => {
			this.renderPage();
		});
		this.renderPage();
	}

	async renderPage() {
		let res = await fetch('/outliers');
		const statusCode = res.status;
		if (statusCode == 200) {
			this.#detectors.hidden = false;
			this.#login.hidden = true;
			let d = await res.json();
			this.renderDetectors(d);
			this.setupEventSource();
		} else if (statusCode == 401) { // unauthorized
			this.#login.hidden = false;
			this.#detectors.hidden = true;
			this.closeEventSource();
		} else {
			this.#detectors.hidden = true;
			this.closeEventSource();
		}
	}

	async renderDetectors(data) {
		this.#detectorsData = data;
		let xdetectors = [];
		let sorted = Object.values(this.#detectorsData['Detectors']).sort((a, b) => {
        	return a.Title.localeCompare(b.Title);
    	});
		for await (const [_, det] of sorted.entries()) {
			let xd = document.createElement('x-detector');
			let existing_detector = this.#detectors.querySelector(`#detector${det.Id}`);
			let {collapsed} = existing_detector ? existing_detector.getDisplayedState() : {collapsed: false};
			await xd.init(det, collapsed);			
			xdetectors.push(xd);
		}
		this.#detectors.replaceChildren(...xdetectors);
	}

	setupEventSource() {
		if (!this.#evSrc || this.#evSrc.readyState === EventSource.CLOSED) {
			this.#evSrc = new EventSource("/events");
			this.#evSrc.onmessage = (e) => {
				//todo: only update changed detector
				this.renderPage();
			};
			this.#evSrc.onerror = () => {
				console.error("EventSource connection error.");
			};
		}
	}

	closeEventSource() {
		if (this.#evSrc) {
			this.#evSrc.close();
			this.#evSrc = null;
		}
	}

}

class XLogin extends HTMLElement {
	constructor() {
		super();
		this.innerHTML = `
			<form>
				<label for="password">Password:</label>
				<input type="password" id="password" name="password" required>
				<button type="button">Login</button>
				<br/>
				<div id="invalidpassword" style="display: none;">Invalid Password</div>
			</form>
		`;
		this.querySelector('form').onsubmit = (e) => {
			e.preventDefault();
			this.submitLogin();
		};
		this.querySelector('button').onclick = (e) => {
			e.preventDefault();
			this.submitLogin();
		};
	}

	async submitLogin() {
		const password = this.querySelector('#password').value;
		const response = await fetch('/login', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			credentials: 'include',
			body: JSON.stringify({ password }),
		});
		if (response.ok) {
			this.querySelector('#invalidpassword').style.display = "none";
			this.dispatchEvent(new CustomEvent('loginsuccess', { bubbles: true }));
		} else {
			this.querySelector('#invalidpassword').style.display = "inline";
			setTimeout(() => {this.querySelector('#invalidpassword').style.display = "none";}, 3000);
		}
	}
}

class XDetector extends HTMLElement {
	detector = null;
	#collapsed = false;
	#display_start = null;
	#display_end = null;
	#datepicker = null;

	getDisplayedState() {
		return {
			collapsed: this.#collapsed
		};
	}

	async init(detector, collapsed) {
		this.detector = detector;
		this.#collapsed = collapsed;
		this.id = `detector${this.detector.Id}`;
		await this.update();
	}

	async update() {
		this.innerHTML = await this.HTML();
		const dr = this.querySelector('.daterange');
		this.#datepicker = flatpickr(dr, 
			{mode: "range", 
			allowInput: true, 
			dateFormat: "d.m.Y",
		});
		this.bindEvents();
		this.drawCharts();
	}

	bindEvents() {
		this.unbindEvents();
		let btn = this.querySelector('button.update');
		if (btn) btn.onclick = () => this.onCheckOutliers();
		
		btn = this.querySelector('button.onoff');
		if (btn) btn.onclick = () => this.onOff();
		
		btn = this.querySelector('button.info');
		if (btn) btn.onclick = () => {
			this.querySelector('.detector-info').classList.toggle('hidden');
		};

		this.onclick = async (e) => {
			if ((e.target.closest('div.detector-header .left') && !e.target.matches('button.info')) || 
				e.target.closest('div.outliers-text') || 
				e.target.closest('div.dim-title')) {
				this.showHide();
			}
		};

		const dr = this.querySelector('.daterange');
		const onDateRangeChange = () => {
			const startVal = this.#datepicker.selectedDates[0] ?? null;
			const endVal = this.#datepicker.selectedDates[1] ?? null;
			this.#display_start = startVal ? new Date(startVal) : null;
			this.#display_end = endVal ? new Date(endVal) : null;
			this.drawCharts();
		}
		if (dr) dr.onchange = onDateRangeChange;
	}
	
	unbindEvents() {
		this.onclick = null;
		this.querySelectorAll('button').forEach(btn => btn.onclick = null);
	}


	
	async HTML() {
		let outliers_text = '';
		if (this.detector.TotalOutliers > 0) {
			outliers_text = `${this.detector.TotalOutliers} outliers`;
			if (this.detector.DimsWithOutliers > 1) {
				outliers_text += ` in ${this.detector.DimsWithOutliers} series`;
			}
		}
		let schedule_text = escapeHTML(this.detector.HCron);
		let upd_text = this.detector.LastUpdate && this.detector.LastUpdate != "0001-01-01T00:00:00Z" ? this.formatDateTime(new Date(this.detector.LastUpdate)) : '-' ;

		let on_off_btn_hidden = this.detector.CronSchedule.trim() === '' ? 'hidden' : '';
		let on_off_btn_text = this.detector.OnOff ? 'On' : 'Off';
		let on_off_btn_off_class = this.detector.OnOff ? '' : 'off';

		let collapse_sign_text = this.#collapsed ? '+' : '-';
		let plots_hidden = this.#collapsed ? 'hidden' : '';

		let detector_info_html = '';
		//todo: simplify?
		const configKeys = [
			"ConnectionName", "DataSQL", 
			"OutputConnectionName", "OutputTable",
			"CronSchedule", "NotifyEmails", 
			"DetectionMethod",
			"Lower", "Upper",
			"AveragingWindow", "Percent", "Sigma", "Period",
			"IQRWindow", "IQRRange"];
		for (const key of configKeys) {
			const value = this.detector.Config?.[key];
			if (value !== undefined && value !== null && value != '') {
				detector_info_html += `
					<p><span class="label">${key}:</span><span class="value">${escapeHTML(String(value))}</span></p>`;
			}
		}
		let html = `
		<div class="detector-header">
			<div class="left">
				<span class="collapse-sign"><strong>${collapse_sign_text}</strong></span>
				<h3 class="detector-title">${escapeHTML(this.detector.Title)}</h3>
				<button class="info">i</button>
			</div>
			<div class="date-range">
				<input class="daterange" type="text" placeholder="Select date range">
			</div>
			<div class="outliers-text">${outliers_text}</div>
			<div class="right">
				<span class="schedule">${schedule_text}</span>
				<button class="update">Update</button>
				<button class="onoff ${on_off_btn_hidden} ${on_off_btn_off_class}">${on_off_btn_text}</button>
			</div>
		</div>
		<div class="detector-info hidden">
			${detector_info_html}
		</div>
		<div class="plots ${plots_hidden}"></div>`;
		return html;
	}

	async drawCharts() {
		const id = this.detector.Id;
		const res = await fetch(`/outliers/plot?id=${id}`);
		if (!res.ok) return;
		const data = await res.json();
		if (!data || !data.outliers) return;

		const container = this.querySelector(".plots") || this;
		container.innerHTML = "";

		for (const [dim, points] of Object.entries(data.outliers)) {
			if (!points.length) continue;

			const plotWrapper = document.createElement("div");
			plotWrapper.classList.add("plot-wrapper");
			const dimLabel = document.createElement("div");
			dimLabel.classList.add("dim-title");
			dimLabel.innerHTML = `<span class="collapse-fill">-</span>${escapeHTML(dim)}`;
			plotWrapper.appendChild(dimLabel);
			const plotDiv = document.createElement("div");
			plotDiv.classList.add("uplot");
			plotWrapper.appendChild(plotDiv);
			const legendDiv = document.createElement("div");
    		legendDiv.classList.add("uplot-legend");
    		plotWrapper.appendChild(legendDiv);
			container.appendChild(plotWrapper);

			let filteredPoints = points;
			if (this.#display_start || this.#display_end) {
				filteredPoints = points.filter(p => {
					const t = new Date(p.T * 1000);
					return (!this.#display_start || this.#display_start <= t) && 
						   (!this.#display_end || t <= this.#display_end);
				});
			}
			if (!filteredPoints.length) continue;

			const x = filteredPoints.map(p => p.T);
			const y = filteredPoints.map(p => p.Value);
			const outliers = filteredPoints.map(p => p.IsOutlier ? p.Value : null);
			const lower = filteredPoints.map(p => p.LowerBound.Valid ? p.LowerBound.Float64 : null);
			const upper = filteredPoints.map(p => p.UpperBound.Valid ? p.UpperBound.Float64 : null);
			const uplotData = [x, y, outliers, lower, upper];

			let time_format = "{YYYY}-{MM}-{DD} {HH}:{mm}";
			if (this.detector.TimeColumnIsDate) {
				time_format = "{YYYY}-{MM}-{DD}";
			}

			const opts = {
				width: plotDiv.clientWidth,
				height: 300,
				padding: [null, null, null, 50], // top, right, bottom, left 
				scales: { x: { time: true }, y: { auto: true } },
				series: [
					{ value: time_format },
					{ label: "Value", stroke: "black", width: 2, points: {show: false} },
					{ label: "Outliers", stroke: "transparent", fill: "transparent", points: {show: true, size: 6, stroke: "red", fill: "red" } },
					{ label: "Lower Bound", stroke: "black", dash: [20, 5], width: 2, points: {show: false}, band: true },
					{ label: "Upper Bound", stroke: "black", dash: [20, 5], width: 2, points: {show: false}, band: true, legend: {show: false} },
				],
				axes: [
					{grid: { show: false }, ticks: { show: false }},
					{grid: { show: false }, ticks: { show: false }},
				],
				cursor: {drag: {x: true, y: false}, lock: true},
				legend: {
					show: true,
					live: true,
					mount: (self, legendEl) => { legendDiv.appendChild(legendEl); }  
				},
				hooks: {
					ready: [
					(u) => {
						const legendRows = legendDiv.querySelectorAll(".u-series");
						legendRows[2].style.display = "none";
						legendRows[3].style.display = "none";
						legendRows[4].style.display = "none";
						legendRows[0].querySelector(".u-marker").style.display = "none";
						legendRows[1].querySelector(".u-marker").style.display = "none";
						const legendTable = legendDiv.querySelector("table.u-legend.u-inline");
						if (legendTable) legendTable.classList.remove("u-inline");
					},
					],
				},
			};
			
			new uPlot(opts, uplotData, plotDiv);
			const legend = legendDiv.querySelector(".u-legend");
			legend.classList.add('hidden');
			const plotArea = plotDiv.querySelector(".u-over");
			plotArea.onmouseenter = () => {
				legend.classList.remove('hidden');
			};
			plotArea.onmouseleave = () => {
				legend.classList.add('hidden');
			};
		}
	}

	async onCheckOutliers() {
		if (!this.detector) return;
		try {
			const res = await fetch(`/outliers/update?id=${encodeURIComponent(this.detector.Id)}`, {
            	method: 'POST'
			});
			if (!res.ok) throw new Error(`HTTP ${res.status}`);
			const result = await res.json();
			this.detector = result.detector;
			await this.update();
		} catch (err) {
			console.error('Error checking outliers:', err);
		}
	}

	async onOff() {
		if (!this.detector) return;
		try {
			const res = await fetch(`/outliers/onoff?id=${encodeURIComponent(this.detector.Id)}`, {
            	method: 'POST'
			});
			if (!res.ok) throw new Error(`HTTP ${res.status}`);
			const result = await res.json();
			this.detector = result.detector;
			await this.update();
		} catch (err) {
			console.error('Error turning on-off:', err);
		}
	}

	async showHide() {
		this.#collapsed = !this.#collapsed;
		const info = this.querySelector('.detector-info');
		const plots = this.querySelector('.plots');
		const collapseSign = this.querySelector('.collapse-sign');	
		if (info && this.#collapsed) {
			info.classList.toggle('hidden', this.#collapsed);
		}
		if (plots) plots.classList.toggle('hidden', this.#collapsed);
		if (collapseSign) {
			collapseSign.textContent = this.#collapsed ? '+' : 'â€“';
		}
	}

	formatDateTime(d) {
		return (
			d.getDate().toString().padStart(2, '0') + "-" +
			(d.getMonth()+1).toString().padStart(2, '0') + "-" +
			d.getFullYear() + " " + 
			d.getHours().toString().padStart(2, '0') + ":" + 
			d.getMinutes().toString().padStart(2, '0')
			// + ":" + d.getSeconds().toString().padStart(2, '0')
		);
	}
}

function escapeHTML(str) {
	const div = document.createElement('div');
	div.textContent = str;
	return div.innerHTML;
}

customElements.define('x-outliers', XOutliers);
customElements.define('x-login', XLogin);
customElements.define('x-detector', XDetector);

</script>
</body>
</html>
