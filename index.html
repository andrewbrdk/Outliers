<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Forecasts</title>
	<style>
		body {
			margin-left: 10%;
			margin-right: 10%;
			font-family: sans-serif;
		}
		x-forecastlist, #allforecasts {
			display: block;
			margin: 0 auto;
		}
		h1 {
			text-align: center;
		}
		h1 a {
			color: black;
			text-decoration: none;
		}	
	</style>
</head>
<body>
	
<x-forecastlist></x-forecastlist>

<script>
class XForecastList extends HTMLElement {
	#allForecasts = null;
	#forecastsData = null;
	
	constructor() {
		super();
		this.innerHTML = `
			<h1><a href="/">Forecasts</a></h1>
			<div id="allforecasts"></div>
			<button>Add New Forecast</button>
		`;
		this.#allForecasts = this.querySelector('#allforecasts');
		this.renderPage();
	}

	async renderPage() {
		let res = await fetch('/forecasts');
		const statusCode = res.status;
		if (statusCode == 200) {
			this.#allForecasts.hidden = false;
			let d = await res.json();
			this.renderForecasts(d);
		}
	}

	async renderForecasts(forecasts_data) {
		this.#forecastsData = forecasts_data;
		let xforecasts = [];
		let sortedForecasts = Object.values(this.#forecastsData['Forecasts']).sort((a, b) => {
        	return a.Title.localeCompare(b.Title);
    	});
		for await (const [_, fc] of sortedForecasts.entries()) {
			let f = document.createElement('x-forecast');
			await f.init(fc);			
			xforecasts.push(f);
		}
		this.#allForecasts.replaceChildren(...xforecasts);
	}
}

class XForecast extends HTMLElement {
	forecast = null;

	getDisplayedState() {
		// pass
	}

	async init(forecast) {
		this.forecast = forecast;
		await this.update();
	}

	async update() {
		this.innerHTML = await this.forecastHTML();
		this.bindEvents();
		this.drawChart();
	}

	bindEvents() {
		this.unbindEvents();
		const btn = this.querySelector('.update-forecast-btn');
		if (btn) {
			btn.addEventListener('click', async () => {
				await this.onUpdateForecast();
			});
		}
	}
	
	unbindEvents() {
		this.querySelectorAll('button').forEach(btn => btn.onclick = null);
	}
	
	async forecastHTML() {
		let html = `
		<h3>${escapeHTML(this.forecast.Title)}</h3>
		<canvas id="forecastChart" height="200"></canvas>
		<p>ConnectionString: ${escapeHTML(this.forecast.ConnectionString)}</p>
		<p>DataTable: ${escapeHTML(this.forecast.DataTable)}</p>
		<p>OutputTable: ${escapeHTML(this.forecast.OutputTable)}</p>
		<p>ForecastHorizon: ${this.forecast.ForecastHorizon}</p>
		<p>ForecastModel: ${escapeHTML(this.forecast.ForecastModel)}</p>
		<button class="update-forecast-btn">Update Forecast</button>`;
		return html;
	}

	async drawChart() {
		const id = this.forecast.Id;
		const res = await fetch(`/api/forecast/plot?id=${id}`);
		const data = await res.json();

		const ctx = this.querySelector('#forecastChart');
		if (!ctx) return;

		if (typeof Chart === 'undefined') {
			await import('https://cdn.jsdelivr.net/npm/chart.js');
		}

		const allPoints = [...data.original, ...data.forecast];
		const labels = [...new Set(allPoints.map(p => p.T))].sort((a, b) => Number(a) - Number(b));
		const origMap = new Map(data.original.map(p => [p.T, p.Value]));
		const forecastMap = new Map(data.forecast.map(p => [p.T, p.Value]));
		const origValues = labels.map(T => origMap.get(T) ?? null);
		const forecastValues = labels.map(T => forecastMap.get(T) ?? null);

		new Chart(ctx, {
		type: 'line',
		data: {
			labels,
			datasets: [
			{
				label: 'Original',
				data: origValues,
				borderColor: 'blue',
				tension: 0.2,
				spanGaps: true,
			},
			{
				label: 'Forecast',
				data: forecastValues,
				borderColor: 'orange',
				borderDash: [5, 5],
				tension: 0.2,
				spanGaps: true,
			},
			],
		},
		options: {
			responsive: true,
			interaction: { mode: 'index', intersect: false },
			stacked: false,
			plugins: {
			title: {
				display: true,
				text: 'Original vs Forecast',
			},
			},
			scales: {
			y: {
				beginAtZero: true,
				title: {
				display: true,
				text: 'Value',
				},
			},
			x: {
				title: {
				display: true,
				text: 'Date',
				},
			},
			},
		},
		});
	}

	async onUpdateForecast() {
		if (!this.forecast) return;

		try {
			const res = await fetch(`/api/forecast/update?id=${encodeURIComponent(this.forecast.Id)}`, {
            	method: 'POST'
			});
			if (!res.ok) throw new Error(`HTTP ${res.status}`);
			const result = await res.json();
			console.log('Forecast updated:', result);

			await this.update();
		} catch (err) {
			console.error('Error updating forecast:', err);
		}
	}

	formatDateTime(d) {
		return (
			d.getDate().toString().padStart(2, '0') + "-" +
			(d.getMonth()+1).toString().padStart(2, '0') + "-" +
			d.getFullYear() + " " + 
			d.getHours().toString().padStart(2, '0') + ":" + 
			d.getMinutes().toString().padStart(2, '0') + ":" +
			d.getSeconds().toString().padStart(2, '0')
		);
	}
}

function escapeHTML(str) {
	const div = document.createElement('div');
	div.textContent = str;
	return div.innerHTML;
}

customElements.define('x-forecast', XForecast);
customElements.define('x-forecastlist', XForecastList);

</script>
</body>
</html>
