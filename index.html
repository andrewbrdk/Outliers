<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Outliers</title>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.min.css">
	<script src="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.iife.min.js"></script>
	<link rel="stylesheet" href="/style.css">
</head>
<body>
	
<x-outliers></x-outliers>

<script>
class XOutliers extends HTMLElement {
	#detectors = null;
	#detectorsData = null;
	#evSrc = null;
	
	constructor() {
		super();
		this.innerHTML = `
	 		<h1><a href="/">Outliers</a></h1>
			<div id="detectors"></div>
			<section class="notifications-section">
				<h2>Notifications</h2>
				<div id="notifications"></div>
			</section>
		`;
		this.#detectors = this.querySelector('#detectors');
		this.renderPage();
	}

	async renderPage() {
		let res = await fetch('/outliers');
		const statusCode = res.status;
		if (statusCode == 200) {
			this.#detectors.hidden = false;
			let d = await res.json();
			this.renderDetectors(d);
			this.setupEventSource();
		} else {
			this.#detectors.hidden = true;
			this.closeEventSource();
		}
		this.loadNotifications();
	}

	async renderDetectors(data) {
		this.#detectorsData = data;
		let xdetectors = [];
		let sorted = Object.values(this.#detectorsData['Detectors']).sort((a, b) => {
        	return a.Title.localeCompare(b.Title);
    	});
		for await (const [_, fc] of sorted.entries()) {
			let f = document.createElement('x-detector');
			await f.init(fc);			
			xdetectors.push(f);
		}
		this.#detectors.replaceChildren(...xdetectors);
	}

	async loadNotifications() {
		try {
			const res = await fetch("/notifications");
			if (!res.ok) throw new Error("Failed to load notifications");
			const data = await res.json();

			const container = document.getElementById("notifications");
			container.innerHTML = "";

			data.forEach(n => {
				const div = document.createElement("div");
				div.className = "notification-card";
				div.innerHTML = `
					<h3>${n.title}</h3>
					<p><b>Type:</b> ${n.type}</p>
					${n.type === "Slack" ? `<p><b>Webhook:</b> ${n.url}</p>` : ""}
					${n.type === "Email" ? `
						<p><b>SMTP:</b> ${n.smtp}</p>
						<p><b>From:</b> ${n.from}</p>
						<p><b>Username:</b> ${n.username}</p>
						<p><b>Common Recipients:</b> ${n.common_recipients}</p>` : ""}
				`;
				container.appendChild(div);
			});
		} catch (err) {
			console.error("Error loading notifications:", err);
		}
	}

	setupEventSource() {
		if (!this.#evSrc || this.#evSrc.readyState === EventSource.CLOSED) {
			this.#evSrc = new EventSource("/events");
			this.#evSrc.onmessage = (e) => {
				//todo: only update changed detector
				this.renderPage();
			};
			this.#evSrc.onerror = () => {
				console.error("EventSource connection error.");
			};
		}
	}

	closeEventSource() {
		if (this.#evSrc) {
			this.#evSrc.close();
			this.#evSrc = null;
		}
	}

}

class XDetector extends HTMLElement {
	detector = null;

	getDisplayedState() {
		// pass
	}

	async init(detector) {
		this.detector = detector;
		await this.update();
	}

	async update() {
		this.innerHTML = await this.HTML();
		this.bindEvents();
		this.drawCharts();
	}

	bindEvents() {
		this.unbindEvents();
		let btn = this.querySelector('button.update');
		if (btn) btn.onclick = () => this.onCheckOutliers();
		
		btn = this.querySelector('button.onoff');
		if (btn) btn.onclick = () => this.onOff();
		
		btn = this.querySelector('button.info');
		if (btn) btn.onclick = () => {
			this.querySelector('.detector-info').classList.toggle('hidden');
		};
	}
	
	unbindEvents() {
		this.querySelectorAll('button').forEach(btn => btn.onclick = null);
		//todo: unnecessary?
		this.querySelectorAll('.u-over').forEach(p => {p.onmouseenter = null; p.onmouseleave = null;});
	}	
	
	async HTML() {
		let outliers_text = '';
		if (this.detector.TotalOutliers > 0) {
			outliers_text = `${this.detector.TotalOutliers} new outliers`;
			if (this.detector.DimsWithOutliers > 1) {
				outliers_text += ` in ${this.detector.DimsWithOutliers} series`;
			}
		}
		let schedule_text = escapeHTML(this.detector.HCron);
		let upd_text = this.detector.LastUpdate && this.detector.LastUpdate != "0001-01-01T00:00:00Z" ? this.formatDateTime(new Date(this.detector.LastUpdate)) : '-' ;

		let on_off_btn_hidden = this.detector.CronSchedule.trim() === '' ? 'hidden' : '';
		let on_off_btn_text = this.detector.OnOff ? 'On' : 'Off';
		let on_off_btn_off_class = this.detector.OnOff ? '' : 'off';

		let html = `
		<div class="detector-header">
			<div class="left">
				<h3>${escapeHTML(this.detector.Title)}</h3>
				<button class="info">i</button>
			</div>
			<div class="outliers-text">${outliers_text}</div>
			<div>
				<span class="schedule">${schedule_text}</span>
				<button class="update">Update</button>
				<button class="onoff ${on_off_btn_hidden} ${on_off_btn_off_class}">${on_off_btn_text}</button>
			</div>
		</div>
		<div class="detector-info hidden">
			<p><span class="label">ConnectionName:</span><span class="value">${escapeHTML(this.detector.ConnectionName)}</span></p>
			<p><span class="label">DataSQL:</span><span class="value">${escapeHTML(this.detector.DataSQL)}</span></p>
			<p><span class="label">OutputTable:</span><span class="value">${escapeHTML(this.detector.OutputTable)}</span></p>
			<p><span class="label">Backsteps:</span><span class="value">${this.detector.Backsteps}</span></p>
			<p><span class="label">DetectionMethod:</span><span class="value">${escapeHTML(this.detector.DetectionMethod)}</span></p>
			<p><span class="label">CronSchedule:</span><span class="value">${escapeHTML(this.detector.CronSchedule)}</span></p>
		</div>
		<div class="plots"></div>`;
		return html;
	}

	async drawCharts() {
		const id = this.detector.Id;
		const res = await fetch(`/outliers/plot?id=${id}`);
		if (!res.ok) return;
		const data = await res.json();
		if (!data || !data.outliers) return;

		const container = this.querySelector(".plots") || this;
		container.innerHTML = "";

		for (const [dim, points] of Object.entries(data.outliers)) {
			if (!points.length) continue;

			const plotWrapper = document.createElement("div");
			plotWrapper.classList.add("plot-wrapper");
			const dimLabel = document.createElement("div");
			dimLabel.classList.add("dim-title");
			dimLabel.textContent = dim;
			plotWrapper.appendChild(dimLabel);
			const plotDiv = document.createElement("div");
			plotDiv.classList.add("uplot");
			plotWrapper.appendChild(plotDiv);
			const legendDiv = document.createElement("div");
    		legendDiv.classList.add("uplot-legend");
    		plotWrapper.appendChild(legendDiv);
			container.appendChild(plotWrapper);

			const x = points.map(p => p.T);
			const y = points.map(p => p.Value);
			const outliers = points.map(p => p.IsOutlier ? p.Value : null);
			const lower = points.map(p => p.LowerBound);
			const upper = points.map(p => p.UpperBound);

			const uplotData = [x, y, outliers, lower, upper];

			const opts = {
				width: plotDiv.clientWidth,
				height: 300,
				//padding: [null, null, null, 50], // top, right, bottom, left 
				scales: { x: { time: true }, y: { auto: true } },
				series: [
					{},
					{ label: "Value", stroke: "black", width: 2, points: {show: false} },
					{ label: "Outliers", stroke: "transparent", fill: "transparent", points: {show: true, size: 6, stroke: "red", fill: "red" } },
					{ label: "Lower Bound", stroke: "black", dash: [20, 5], width: 2, points: {show: false}, band: true },
					{ label: "Upper Bound", stroke: "black", dash: [20, 5], width: 2, points: {show: false}, band: true, legend: {show: false} },
				],
				axes: [
					{grid: { show: false }, ticks: { show: false }},
					{grid: { show: false }, ticks: { show: false }},
				],
				cursor: {drag: {x: true, y: false}, lock: true},
				legend: {
					show: true,
					live: true,
					mount: (self, legendEl) => { legendDiv.appendChild(legendEl); }  
				},
				hooks: {
					ready: [
					(u) => {
						const legendRows = legendDiv.querySelectorAll(".u-series");
						legendRows[2].style.display = "none";
						legendRows[3].style.display = "none";
						legendRows[4].style.display = "none";
						legendRows[1].querySelector(".u-marker").style.display = "none";
					},
					],
				},
			};
			
			new uPlot(opts, uplotData, plotDiv);
			const legend = legendDiv.querySelector(".u-legend");
			legend.classList.add('hidden');
			const plotArea = plotDiv.querySelector(".u-over");
			plotArea.onmouseenter = () => {
				legend.classList.remove('hidden');
			};
			plotArea.onmouseleave = () => {
				legend.classList.add('hidden');
			};
		}
	}

	async onCheckOutliers() {
		if (!this.detector) return;
		try {
			const res = await fetch(`/outliers/update?id=${encodeURIComponent(this.detector.Id)}`, {
            	method: 'POST'
			});
			if (!res.ok) throw new Error(`HTTP ${res.status}`);
			const result = await res.json();
			this.detector = result.detector;
			await this.update();
		} catch (err) {
			console.error('Error checking outliers:', err);
		}
	}

	async onOff() {
		if (!this.detector) return;
		try {
			const res = await fetch(`/outliers/onoff?id=${encodeURIComponent(this.detector.Id)}`, {
            	method: 'POST'
			});
			if (!res.ok) throw new Error(`HTTP ${res.status}`);
			const result = await res.json();
			this.detector = result.detector;
			await this.update();
		} catch (err) {
			console.error('Error turning on-off:', err);
		}
	}

	formatDateTime(d) {
		return (
			d.getDate().toString().padStart(2, '0') + "-" +
			(d.getMonth()+1).toString().padStart(2, '0') + "-" +
			d.getFullYear() + " " + 
			d.getHours().toString().padStart(2, '0') + ":" + 
			d.getMinutes().toString().padStart(2, '0')
			// + ":" + d.getSeconds().toString().padStart(2, '0')
		);
	}
}

function escapeHTML(str) {
	const div = document.createElement('div');
	div.textContent = str;
	return div.innerHTML;
}

customElements.define('x-detector', XDetector);
customElements.define('x-outliers', XOutliers);

</script>
</body>
</html>
