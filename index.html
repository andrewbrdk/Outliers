<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Outliers</title>
	<link rel="stylesheet" href="libs/uPlot.min.css">
	<script src="libs/uPlot.iife.min.js"></script>
	<link rel="stylesheet" href="libs/flatpickr.min.css">
	<script src="libs/flatpickr.min.js"></script>
	<link rel="stylesheet" href="/style.css">
</head>
<body>
	
<x-outliers></x-outliers>

<script>
class XOutliers extends HTMLElement {
	#login = null;
	#detectors = null;
	#evSrc = null;
	
	constructor() {
		super();
		this.innerHTML = `
	 		<h1><a href="/">Outliers</a></h1>
			<x-login></x-login>
			<div id="detectors"></div>
		`;
		this.#detectors = this.querySelector('#detectors');
		this.#login = this.querySelector('x-login');
		this.#login.hidden = true;
		this.#detectors.hidden = true;
		this.addEventListener('loginsuccess', (e) => {
			this.renderPage();
		});
		this.renderPage();
	}

	async renderPage() {
		let res = await fetch('/outliers');
		const statusCode = res.status;
		if (statusCode == 200) {
			this.#detectors.hidden = false;
			this.#login.hidden = true;
			let d = await res.json();
			this.renderDetectors(d);
			this.setupEventSource();
		} else if (statusCode == 401) { // unauthorized
			this.#login.hidden = false;
			this.#detectors.hidden = true;
			this.closeEventSource();
		} else {
			this.#detectors.hidden = true;
			this.closeEventSource();
		}
	}

	async renderDetectors(data) {
		let detectorsData = data;
		let xdetectors = [];
		let sorted = Object.values(detectorsData['Detectors']).sort((a, b) => {
        	return a.Title.localeCompare(b.Title);
    	});
		for await (const [_, d] of sorted.entries()) {
			let xd = document.createElement('x-detector');
			let existing_detector = this.#detectors.querySelector(`#detector${d.Id}`);
			let {collapsed} = existing_detector ? existing_detector.getDisplayedState() : {collapsed: false};
			await xd.init(d, collapsed);			
			xdetectors.push(xd);
			//todo: store this.#xdetectors = {id: xd} map
		}
		this.#detectors.replaceChildren(...xdetectors);
	}

	setupEventSource() {
		if (!this.#evSrc || this.#evSrc.readyState === EventSource.CLOSED) {
			this.#evSrc = new EventSource("/events");
			this.#evSrc.onmessage = (e) => this.handleServerEvent(e);
			this.#evSrc.onerror = () => {
				console.error("EventSource connection error.");
			};
		}
	}

	handleServerEvent(e) {
		let msg;
		try {
			msg = JSON.parse(e.data);
		} catch {
			console.warn("Invalid SSE message:", e.data);
			return;
		}
		if (!msg.event) {
			console.warn("Missing .event:", msg);
			return;
		}

		if (msg.event == "config_reload") {
			this.renderPage();
		} else if (["detector_updated", "detector_running", "detector_onoff"].includes(msg.event)) {
			const el = document.querySelector(`#detector${msg.id}`);
			if (!el || (el.detector.Title != msg.title)) { 
				this.renderPage(); 
				return; 
			}
			el.updateState(); 
		} else {
			console.warn("Unknown event:", msg);
		}
	};

	closeEventSource() {
		if (this.#evSrc) {
			this.#evSrc.close();
			this.#evSrc = null;
		}
	}

}

class XLogin extends HTMLElement {
	constructor() {
		super();
		this.innerHTML = `
			<form>
				<label for="password">Password:</label>
				<input type="password" id="password" name="password" required>
				<button type="button">Login</button>
				<br/>
				<div id="invalidpassword" style="display: none;">Invalid Password</div>
			</form>
		`;
		this.querySelector('form').onsubmit = (e) => {
			e.preventDefault();
			this.submitLogin();
		};
		this.querySelector('button').onclick = (e) => {
			e.preventDefault();
			this.submitLogin();
		};
	}

	async submitLogin() {
		const password = this.querySelector('#password').value;
		const response = await fetch('/login', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			credentials: 'include',
			body: JSON.stringify({ password }),
		});
		if (response.ok) {
			this.querySelector('#invalidpassword').style.display = "none";
			this.dispatchEvent(new CustomEvent('loginsuccess', { bubbles: true }));
		} else {
			this.querySelector('#invalidpassword').style.display = "inline";
			setTimeout(() => {this.querySelector('#invalidpassword').style.display = "none";}, 3000);
		}
	}
}

class XDetector extends HTMLElement {
	detector = null;
	//use a combined dict for uplots and wrappers?
	#uplots = {};
	#plotWrappers = {};
	#collapsed = false;
	#display_start = null;
	#display_end = null;
	#datepicker = null;
	#filteredOutliersCount = null;
	#filteredOutliersDimCount = null;

	getDisplayedState() {
		return {
			collapsed: this.#collapsed
		};
	}

	async init(detector, collapsed) {
		this.detector = detector;
		this.#collapsed = collapsed;
		this.id = `detector${this.detector.Id}`;
		await this.render();
	}

	async updateState() {
		//todo: fetch by id
		const res = await fetch(`/outliers`);
		if (!res.ok) return;
		const data = await res.json();
		if (!data || !data.Detectors) return;
		const d = data.Detectors[this.detector.Id];
		if (!d) return;
		this.detector = d
		await this.render();
	}

	async render() {
		this.innerHTML = await this.HTML();
		this.setupDatePicker();
		this.bindEvents();
		//todo: move into HTML()
		const p = this.querySelector('.plots');
		for (const [dim, wrapper] of Object.entries(this.#plotWrappers)) {
			p.appendChild(wrapper);
		}
		this.drawCharts();
		//todo: 
		//await this.drawCharts();
		//this.updateOutliersCountText();
	}

	async HTML() {
		let outliers_text = '';
		let schedule_text = escapeHTML(this.detector.HCron);
		let upd_text = this.detector.LastUpdate && this.detector.LastUpdate != "0001-01-01T00:00:00Z" ? this.formatDateTime(new Date(this.detector.LastUpdate)) : '-' ;
		const update_btn_hidden = this.detector.StatusCode == 0 ? '' : 'hidden';
		const cancel_btn_hidden = this.detector.StatusCode == 0 ? 'hidden' : '';

		let on_off_btn_hidden = this.detector.CronSchedule.trim() === '' ? 'hidden' : '';
		let on_off_btn_text = this.detector.OnOff ? 'On' : 'Off';
		let on_off_btn_off_class = this.detector.OnOff ? '' : 'off';

		let collapse_sign_text = this.#collapsed ? '+' : '-';
		let plots_hidden = this.#collapsed ? 'hidden' : '';

		//todo: make explicit
		let detector_info_html = '';
		const configKeys = [
			"ConnectionName", "DataSQL", 
			"OutputConnectionName", "OutputTable",
			"CronSchedule", "NotifyEmails", "PlotLookback",
			"DetectionMethod",
			"Lower", "Upper",
			"AveragingWindow", "Percent", "Sigma", "Period",
			"IQRWindow", "IQRRange"];
		for (const key of configKeys) {
			const value = this.detector.Config?.[key];
			if (value !== undefined && value !== null && value != '') {
				detector_info_html += `
					<p><span class="label">${key}:</span><span class="value">${escapeHTML(String(value))}</span></p>`;
			}
		}
		let html = `
		<div class="detector-header">
			<div class="left">
				<span class="collapse-sign"><strong>${collapse_sign_text}</strong></span>
				<h3 class="detector-title">${escapeHTML(this.detector.Title)}</h3>
				<button class="info">i</button>
			</div>
			<div class="date-range">
				<input class="daterange" type="text" placeholder="Date range">
			</div>
			<div class="outliers-text">${outliers_text}</div>
			<div class="right">
				<span class="schedule">${schedule_text}</span>
				<button class="update ${update_btn_hidden}">Update</button>
				<button class="cancel ${cancel_btn_hidden}">Cancel</button>
				<button class="onoff ${on_off_btn_hidden} ${on_off_btn_off_class}">${on_off_btn_text}</button>
			</div>
		</div>
		<div class="detector-info hidden">
			${detector_info_html}
		</div>
		<div class="plots ${plots_hidden}"></div>`;
		//todo: existing plots are discarded; attach existing plotWrappers 
		return html;
	}

	setupDatePicker() {
		const dr = this.querySelector('.daterange');
		const pars = {
			mode: "range", 
			allowInput: true, 
			dateFormat: "d.m.Y",
		}	
		this.#datepicker = flatpickr(dr, pars);
		if (this.detector.PlotLookback) {
			const today = new Date();
			const startDate = new Date();
			startDate.setDate(today.getDate() - this.detector.PlotLookback);
			this.#datepicker.setDate([startDate, today])
			this.#display_start = startDate;
			this.#display_end = today;
		}
	}

	bindEvents() {
		this.unbindEvents();
		let btn = this.querySelector('button.update');
		if (btn) btn.onclick = () => this.updateDetector();
		
		btn = this.querySelector('button.cancel');
		if (btn) btn.onclick = () => this.cancelDetectorUpdate();
		
		btn = this.querySelector('button.onoff');
		if (btn) btn.onclick = () => this.onOff();
		
		btn = this.querySelector('button.info');
		if (btn) btn.onclick = () => {
			this.querySelector('.detector-info').classList.toggle('hidden');
		};

		this.onclick = async (e) => {
			if ((e.target.closest('div.detector-header .left') && !e.target.matches('button.info')) || 
				e.target.closest('div.outliers-text') || 
				e.target.closest('div.dim-title')) {
				this.showHide();
			}
		};

		const dr = this.querySelector('.daterange');
		const onDateRangeChange = async () => {
			const startVal = this.#datepicker.selectedDates[0] ?? null;
			const endVal = this.#datepicker.selectedDates[1] ?? null;
			this.#display_start = startVal ? new Date(startVal) : null;
			this.#display_end = endVal ? new Date(endVal) : null;
			this.drawCharts();
			//todo: 
			//await this.drawCharts();
			//this.updateOutliersCountText();
		}
		if (dr) dr.onchange = onDateRangeChange;
	}
	
	unbindEvents() {
		this.onclick = null;
		this.querySelectorAll('button').forEach(btn => btn.onclick = null);
	}

	async drawCharts() {
		const id = this.detector.Id;
		const res = await fetch(`/outliers/plot?id=${id}`);
		if (!res.ok) return;
		const data = await res.json();
		if (!data || !data.outliers) return;

		const container = this.querySelector(".plots");

		this.#filteredOutliersDimCount = 0;
		this.#filteredOutliersCount = 0;

		const receivedDims = new Set(Object.keys(data.outliers));
		for (const dim of Object.keys(this.#uplots)) {
			if (!receivedDims.has(dim)) {
				this.#uplots[dim].destroy();
				this.#plotWrappers[dim].remove();
				delete this.#uplots[dim];
				delete this.#plotWrappers[dim];
			}
		}

		for (const [dim, points] of Object.entries(data.outliers)) {
			if (!points.length) continue;

			let filteredPoints = points;
			if (this.#display_start || this.#display_end) {
				filteredPoints = points.filter(p => {
					const t = new Date(p.T * 1000);
					return (!this.#display_start || this.#display_start <= t) && 
						   (!this.#display_end || t <= this.#display_end);
				});
			}
			const ocnt = filteredPoints.filter(p => p.IsOutlier).length
			this.#filteredOutliersCount += ocnt;
			this.#filteredOutliersDimCount += (ocnt > 0) ? 1 : 0;

			const x = filteredPoints.map(p => p.T);
			const y = filteredPoints.map(p => p.Value);
			const outliers = filteredPoints.map(p => p.IsOutlier ? p.Value : null);
			const lower = filteredPoints.map(p => p.LowerBound.Valid ? p.LowerBound.Float64 : null);
			const upper = filteredPoints.map(p => p.UpperBound.Valid ? p.UpperBound.Float64 : null);
			const uplotData = [x, y, outliers, lower, upper];

			let time_format = "{YYYY}-{MM}-{DD} {HH}:{mm}";
			if (this.detector.TimeColumnIsDate) {
				time_format = "{YYYY}-{MM}-{DD}";
			}
			let xScale = { time: true };
			if (this.#display_start !== null) xScale.min = this.#display_start.getTime() / 1000;
			if (this.#display_end   !== null) xScale.max = this.#display_end.getTime() / 1000;

			if (this.#uplots[dim]) {
				this.#uplots[dim].setData(uplotData);
				this.#uplots[dim].setScale("x", xScale);
				continue;
			}

			const plotWrapper = document.createElement("div");
			plotWrapper.classList.add("plot-wrapper");
			const dimLabel = document.createElement("div");
			dimLabel.classList.add("dim-title");
			dimLabel.innerHTML = `<span class="collapse-fill">-</span>${escapeHTML(dim)}`;
			plotWrapper.appendChild(dimLabel);
			const plotDiv = document.createElement("div");
			plotDiv.classList.add("uplot");
			plotWrapper.appendChild(plotDiv);
			const legendDiv = document.createElement("div");
    		legendDiv.classList.add("uplot-legend");
    		plotWrapper.appendChild(legendDiv);
			container.appendChild(plotWrapper);

			const opts = {
				width: plotDiv.clientWidth,
				height: 300,
				padding: [null, null, null, 50], // top, right, bottom, left 
				scales: { x: xScale, y: { auto: true } },
				series: [
					{ value: time_format },
					{ label: "Value", stroke: "black", width: 2, points: {show: false} },
					{ label: "Outliers", stroke: "transparent", fill: "transparent", points: {show: true, size: 6, stroke: "red", fill: "red" } },
					{ label: "Lower Bound", stroke: "black", dash: [20, 5], width: 2, points: {show: false}, band: true },
					{ label: "Upper Bound", stroke: "black", dash: [20, 5], width: 2, points: {show: false}, band: true, legend: {show: false} },
				],
				axes: [
					{grid: { show: false }, ticks: { show: false }},
					{grid: { show: false }, ticks: { show: false }},
				],
				cursor: {drag: {x: true, y: false}, lock: true},
				legend: {
					show: true,
					live: true,
					mount: (self, legendEl) => { legendDiv.appendChild(legendEl); }  
				},
				hooks: {
					ready: [
					(u) => {
						const legendRows = legendDiv.querySelectorAll(".u-series");
						legendRows[2].style.display = "none";
						legendRows[3].style.display = "none";
						legendRows[4].style.display = "none";
						legendRows[0].querySelector(".u-marker").style.display = "none";
						legendRows[1].querySelector(".u-marker").style.display = "none";
						const legendTable = legendDiv.querySelector("table.u-legend.u-inline");
						if (legendTable) legendTable.classList.remove("u-inline");
					},
					],
				},
			};
			
			const u = new uPlot(opts, uplotData, plotDiv);
			const legend = legendDiv.querySelector(".u-legend");
			legend.classList.add('hidden');
			const plotArea = plotDiv.querySelector(".u-over");
			plotArea.onmouseenter = () => { legend.classList.remove('hidden'); };
			plotArea.onmouseleave = () => { legend.classList.add('hidden'); };

			this.#uplots[dim] = u;
            this.#plotWrappers[dim] = plotWrapper;
		}
		//todo: move into this.render(), fix await issues
		this.updateOutliersCountText();
	}

	updateOutliersCountText() {
		const ot = this.querySelector('.outliers-text');
		let outliers_text = '';
		if (this.#filteredOutliersCount > 0) {
			outliers_text = `${this.#filteredOutliersCount} ${this.#filteredOutliersCount > 1 ? 'outliers' : 'outlier'}`;
			if (this.detector.HasDims) {
				outliers_text += ` in ${this.#filteredOutliersDimCount} series`;
			}
		}
		ot.textContent = outliers_text;
	}

	async updateDetector() {
		if (!this.detector) return;
		const res = await fetch(`/outliers/update?id=${encodeURIComponent(this.detector.Id)}`, {
        	method: 'POST'
		});
		if (!res.ok) {
			console.error('Error updating detector:', res.status, res.statusText);
		}
	}

	async cancelDetectorUpdate() {
		if (!this.detector) return;
		const res = await fetch(`/outliers/cancel?id=${encodeURIComponent(this.detector.Id)}`, {
        	method: 'POST'
		});
		if (!res.ok) {
			console.error('Error cancelling detector update:', res.status, res.statusText);
		}
	}

	async onOff() {
		if (!this.detector) return;
		const res = await fetch(`/outliers/onoff?id=${encodeURIComponent(this.detector.Id)}`, {
			method: 'POST'
		});
		if (!res.ok) {
			console.error('Error turning on-off:', res.status, res.statusText);
		}
	}

	async showHide() {
		this.#collapsed = !this.#collapsed;
		const info = this.querySelector('.detector-info');
		const plots = this.querySelector('.plots');
		const collapseSign = this.querySelector('.collapse-sign');	
		if (info && this.#collapsed) {
			info.classList.toggle('hidden', this.#collapsed);
		}
		if (plots) plots.classList.toggle('hidden', this.#collapsed);
		if (collapseSign) {
			collapseSign.textContent = this.#collapsed ? '+' : 'â€“';
		}
	}

	formatDateTime(d) {
		return (
			d.getDate().toString().padStart(2, '0') + "-" +
			(d.getMonth()+1).toString().padStart(2, '0') + "-" +
			d.getFullYear() + " " + 
			d.getHours().toString().padStart(2, '0') + ":" + 
			d.getMinutes().toString().padStart(2, '0')
			// + ":" + d.getSeconds().toString().padStart(2, '0')
		);
	}
}

function escapeHTML(str) {
	const div = document.createElement('div');
	div.textContent = str;
	return div.innerHTML;
}

customElements.define('x-outliers', XOutliers);
customElements.define('x-login', XLogin);
customElements.define('x-detector', XDetector);

</script>
</body>
</html>
